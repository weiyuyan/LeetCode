#!/usr/bin/env python
# -*- coding: utf-8 -*-
# author：ShidongDu time:2020/3/31
'''
给定两个整数 a 和 b，求 a 和 b 之间的所有数字中0~9的出现次数。

例如，a=1024，b=1032，则 a 和 b 之间共有9个数如下：

1024 1025 1026 1027 1028 1029 1030 1031 1032

其中‘0’出现10次，‘1’出现10次，‘2’出现7次，‘3’出现3次等等…

输入格式
输入包含多组测试数据。

每组测试数据占一行，包含两个整数 a 和 b。

当读入一行为0 0时，表示输入终止，且该行不作处理。

输出格式
每组数据输出一个结果，每个结果占一行。

每个结果包含十个用空格隔开的数字，第一个数字表示‘0’出现的次数，第二个数字表示‘1’出现的次数，以此类推。

数据范围
0<a,b<100000000
输入样例：
1 10
44 497
346 542
1199 1748
1496 1403
1004 503
1714 190
1317 854
1976 494
1001 1960
0 0
输出样例：
1 2 1 1 1 1 1 1 1 1
85 185 185 185 190 96 96 96 95 93
40 40 40 93 136 82 40 40 40 40
115 666 215 215 214 205 205 154 105 106
16 113 19 20 114 20 20 19 19 16
107 105 100 101 101 197 200 200 200 200
413 1133 503 503 503 502 502 417 402 412
196 512 186 104 87 93 97 97 142 196
398 1375 398 398 405 499 499 495 488 471
294 1256 296 296 296 296 287 286 286 247
'''
# 分情况讨论：count(n, x):表示1~n中x出现的次数，x∈[0, 9]
# 那么，求[a,b]之间x出现的次数：count(b, x) - count(a-1, x)
# 举例：求(1, n)中'1'出现的次数
# 如：对于数字n = abcdefg，那么我们分别求出1在每一位上出现的次数
# 比如求1在第4位上的数字
# 1 <= xxx1yyy <= abcdefg
# ①当xxx = 000~abc-1， 那么，yyy可以取到000~999，一共是abc*1000种选法
# ②当xxx = abc，
#       ②.(1) 当d<1时(即d为0)，需要abc1yyy <= abcdefg，但是abc1yyy 恒> abc0efg，yyy不管取什么都不行，一共0种选法
#       ②.(2) 当d==1时，需要abc1yyy <= abcdefg，yyy可以取[0, efg]，一共efg+1种选法
#       ③.(3) 当d>1时，需要abc1yyy <= abcdefg，yyy可以取[0, 999]，一共1000种选法
# 边界问题：当1出现在第1位时，那么第①种情况就不存在了


# 状态表示： ①集合：4     ②属性：
# 状态计算：
class Solution:
    def num_bit(self, a: int, b: int):
        if a==0 and b==0:
            return
        pass

if __name__ == '__main__':
    store = []
    a, b = list(map(int, input().split()))
    store.append([a, b])
    solution = Solution()
    res = []
    for i in store:
        res.append(solution.num_bit(i[0], i[1]))

    for j in res:
        print(j)